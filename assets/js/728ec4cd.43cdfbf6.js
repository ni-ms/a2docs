"use strict";(self.webpackChunkscenedocs=self.webpackChunkscenedocs||[]).push([[221],{3905:(n,e,t)=>{t.d(e,{Zo:()=>c,kt:()=>u});var a=t(7294);function l(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function r(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){l(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function i(n,e){if(null==n)return{};var t,a,l=function(n,e){if(null==n)return{};var t,a,l={},r=Object.keys(n);for(a=0;a<r.length;a++)t=r[a],e.indexOf(t)>=0||(l[t]=n[t]);return l}(n,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)t=r[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(l[t]=n[t])}return l}var s=a.createContext({}),f=function(n){var e=a.useContext(s),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},c=function(n){var e=f(n.components);return a.createElement(s.Provider,{value:e},n.children)},h="mdxType",g={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(n,e){var t=n.components,l=n.mdxType,r=n.originalType,s=n.parentName,c=i(n,["components","mdxType","originalType","parentName"]),h=f(t),d=l,u=h["".concat(s,".").concat(d)]||h[d]||g[d]||r;return t?a.createElement(u,o(o({ref:e},c),{},{components:t})):a.createElement(u,o({ref:e},c))}));function u(n,e){var t=arguments,l=e&&e.mdxType;if("string"==typeof n||l){var r=t.length,o=new Array(r);o[0]=d;var i={};for(var s in e)hasOwnProperty.call(e,s)&&(i[s]=e[s]);i.originalType=n,i[h]="string"==typeof n?n:l,o[1]=i;for(var f=2;f<r;f++)o[f]=t[f];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3867:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>f});var a=t(7462),l=(t(7294),t(3905));const r={sidebar_position:5,sidebar_label:"Code"},o="A deep dive into the code",i={unversionedId:"code",id:"code",title:"A deep dive into the code",description:"The code for the assignment is:",source:"@site/docs/code.md",sourceDirName:".",slug:"/code",permalink:"/a2docs/docs/code",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,sidebar_label:"Code"},sidebar:"tutorialSidebar",previous:{title:"Methodology",permalink:"/a2docs/docs/method"},next:{title:"Team Members",permalink:"/a2docs/docs/credits"}},s={},f=[],c={toc:f};function h(n){let{components:e,...t}=n;return(0,l.kt)("wrapper",(0,a.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"a-deep-dive-into-the-code"},"A deep dive into the code"),(0,l.kt)("p",null,"The code for the assignment is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <GL/freeglut.h>\n\n#include <GL/glut.h>\n#include <iostream>\n\n\n#ifndef M_PI\n#define M_PI    3.14159265358979323846\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4305 4244)\n#endif\n\n\nstatic const char *helpprompt[] = {"Press F1 for help", 0};\nstatic const char *helptext[] = {\n        "Rotate: left mouse drag",\n        " Scale: right mouse drag up/down",\n        "   Pan: middle mouse drag",\n        "",\n        "Toggle fullscreen: f",\n        "Toggle animation: space",\n        "Quit: escape",\n        0\n};\n\nvoid idle(void);\nvoid display(void);\nvoid print_help(void);\nvoid reshape(int x, int y);\nvoid keypress(unsigned char key, int x, int y);\nvoid skeypress(int key, int x, int y);\nvoid mouse(int bn, int st, int x, int y);\nvoid motion(int x, int y);\n\nvoid drawBush(GLdouble x, GLdouble y, GLdouble z, GLdouble r, GLdouble h)\n{\n\n\n    // Load the texture for the bush\n    GLfloat colour[] = { 0.0f, 0.5f, 0.0f, 1.0f };\n    glMaterialfv(GL_FRONT, GL_DIFFUSE, colour);\n    glTranslated(x, y, z);\n    // Begin drawing the bush\n    glBegin(GL_TRIANGLES);\n\n    // Create the first triangle of the bush\n    glTexCoord2f(0.0, 0.0);\n    glVertex3f(-0.5, 0.0, 0.0);\n\n    glTexCoord2f(1.0, 0.0);\n    glVertex3f(0.5, 0.0, 0.0);\n\n    glTexCoord2f(0.5, 1.0);\n    glVertex3f(0.0, 0.5, 0.0);\n\n    // Create the second triangle of the bush\n    glTexCoord2f(0.0, 0.0);\n    glVertex3f(-0.4, 0.0, 0.1);\n\n    glTexCoord2f(1.0, 0.0);\n    glVertex3f(0.4, 0.0, 0.1);\n\n    glTexCoord2f(0.5, 1.0);\n    glVertex3f(0.0, 0.4, 0.1);\n\n    // End drawing the bush\n    glEnd();\n\n    // Disable texture mapping\n    glDisable(GL_TEXTURE_2D);\n}\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <GL/glut.h>\n#include <sstream>\n#include <iterator>\n\n// structure to store a vertex\nstruct Vertex\n{\n    float x, y, z;\n};\n\n// structure to store a face\nstruct Face\n{\n    int v1, v2, v3;\n};\n\nstd::vector<Vertex> vertices;  // vector to store vertices\nstd::vector<Face> faces;       // vector to store faces\n\nvoid loadObj(const char* filename, float xPos, float yPos, float zPos, float scale, GLfloat colour[])\n{\n    // open the file\n    std::ifstream file(filename);\n    if (!file.is_open())\n    {\n        std::cerr << "Error: Unable to open file \'" << filename << "\'" << std::endl;\n        return;\n    }\n\n\n    // read the file line by line\n    std::string line;\n    Face face{};\n    Vertex vertex{};\n    Vertex normal{};\n    while (std::getline(file, line))\n    {\n        // split the line into tokens\n        std::istringstream iss(line);\n        std::vector<std::string> tokens{std::istream_iterator<std::string>{iss}, std::istream_iterator<std::string>{}};\n\n        // parse the line based on the first token\n        if (tokens.empty())\n            continue;\n\n        if (tokens[0] == "v")\n        {\n            // line defines a vertex\n            vertex.x = std::stof(tokens[1]);\n            vertex.y = std::stof(tokens[2]);\n            vertex.z = std::stof(tokens[3]);\n            vertices.push_back(vertex);\n        }\n        else if (tokens[0] == "f")\n        {\n            // line defines a face\n            face.v1 = std::stoi(tokens[1]);\n            face.v2 = std::stoi(tokens[2]);\n            face.v3 = std::stoi(tokens[3]);\n            faces.push_back(face);\n        }\n    }\n    file.close();\n\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_LIGHTING);\n    glEnable(GL_LIGHT0);\n\n\n\n    // Set the colour of the model\n    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, colour);\n    for(const Face& face : faces){\n    // Retrieve the vertices for this face\n    const Vertex& v1 = vertices[face.v1 - 1];\n    const Vertex& v2 = vertices[face.v2 - 1];\n    const Vertex& v3 = vertices[face.v3 - 1];\n\n    glBegin(GL_TRIANGLES);\n        glVertex3f(v1.x * scale + xPos, v1.y * scale + yPos, v1.z * scale + zPos);\n        glVertex3f(v2.x * scale + xPos, v2.y * scale + yPos, v2.z * scale + zPos);\n        glVertex3f(v3.x * scale + xPos, v3.y * scale + yPos, v3.z * scale + zPos);\n    glEnd();\n}\n\n//ensure that only one object is rendered\n    vertices.clear();\n    faces.clear();\n\n\n\n}\n\n\n\n void DrawCube(GLfloat centerPosX, GLfloat centerPosY, GLfloat centerPosZ, GLfloat Clength, GLfloat Cbreadth, GLfloat Cheight, GLfloat colour[])\n{\n    GLfloat halfLength = Clength * 0.5f;\n    GLfloat halfbreadth = Cbreadth * 0.5f;\n    GLfloat halfheight = Cheight * 0.5f;\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_LIGHTING);\n    glEnable(GL_LIGHT0);\n    glShadeModel(GL_SMOOTH);\n    glDisable(GL_CULL_FACE);\n    GLfloat mat_ambient[] = { 0.7f, 0.7f, 0.7f, 1.0f };\n    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);\n    GLfloat mat_diffuse[] = { 0.1f, 0.5f, 0.8f, 1.0f };\n    glMaterialfv(GL_FRONT, GL_DIFFUSE, colour);\n    GLfloat mat_specular[] = { 1.0f, 1.0f, 1.0f, 1.0f };\n    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);\n    GLfloat mat_shininess[] = { 50.0f };\n    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);\n    GLfloat lightIntensity[] = { 0.7f, 0.7f, 0.7f, 1.0f };\n    GLfloat light_position[] = { 2.0f, 6.0f, 3.0f, 0.0f };\n    glLightfv(GL_LIGHT0, GL_POSITION, light_position);\n    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightIntensity);\n    glBegin(GL_QUADS);\n    // Top face (y = 1.0f)\n    // Define vertices in counter-clockwise (CCW) order with normal pointing out\n    glNormal3f(0.0f, 1.0f, 0.0f);     // Normal points up\n    glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v1\n    glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v2\n    glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v3\n    glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v4\n    // Bottom face (y = -1.0f)\n    glNormal3f(0.0f, -1.0f, 0.0f);    // Normal points down\n    glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v5\n    glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v6\n    glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v7\n    glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v8\n    // Front face  (z = 1.0f)\n    glNormal3f(0.0f, 0.0f, 1.0f);     // Normal points towards viewer\n    glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v9\n    glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v10\n    glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v11\n    glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v12\n    // Back face (z = -1.0f)\n    glNormal3f(0.0f, 0.0f, -1.0f);    // Normal points away from viewer\n    glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v13\n    glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v14\n    glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v15\n    glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v16\n    // Left face (x = -1.0f)\n    glNormal3f(-1.0f, 0.0f, 0.0f);    // Normal points left\n    glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v17\n    glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v18\n    glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v19\n    glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v20\n    // Right face (x = 1.0f)\n    glNormal3f(1.0f, 0.0f, 0.0f);     // Normal points right\n    glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v21\n    glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v22\n    glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v23\n    glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v24\n    glEnd();\n}\n\n\n\nint win_width, win_height;\nfloat cam_theta, cam_phi = 25, cam_dist = 8, cam_yaw = 0;\nfloat cam_pan[3];\nint mouse_x, mouse_y;\nint bnstate[8];\nint anim, help;\nlong anim_start;\nlong nframes;\n\n#ifndef GL_FRAMEBUFFER_SRGB\n#define GL_FRAMEBUFFER_SRGB 0x8db9\n#endif\n\n#ifndef GL_MULTISAMPLE\n#define GL_MULTISAMPLE 0x809d\n#endif\n\n\nint main(int argc, char **argv)\n{\n    glutInit(&argc, argv);\n    glutInitWindowSize(800, 600);\n    glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE);\n    glutCreateWindow("freeglut 3D view demo");\n\n    glutDisplayFunc(display);\n    glutReshapeFunc(reshape);\n    glutKeyboardFunc(keypress);\n    glutSpecialFunc(skeypress);\n    glutMouseFunc(mouse);\n    glutMotionFunc(motion);\n\n    glEnable(GL_DEPTH_TEST);\n\n    glEnable(GL_LIGHTING);\n    glEnable(GL_LIGHT0);\n//    glEnable(GL_MULTISAMPLE);\n//    glEnable(GL_FRAMEBUFFER_SRGB);\n//    glColorMaterial ( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE ) ;\n//    glEnable(GL_COLOR_MATERIAL);\n    glutMainLoop();\n    return 0;\n}\n\nvoid idle(void)\n{\n    glutPostRedisplay();\n}\n\nvoid display(void)\n{\n    long tm;\n    float lpos[] = {-1, 2, 3, 0};\n\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    glTranslatef(0, 0, -cam_dist);\n    glRotatef(cam_phi, 1, 0, 0);\n    glRotatef(cam_theta, 0, 1, 0);\n    glRotatef(cam_yaw, 0, 0, 1);\n    glTranslatef(cam_pan[0], cam_pan[1], cam_pan[2]);\n\n\n    GLfloat colorTree[] = { 0.0f, 0.0f, 1.0f, 1.0f };\n    //IMPORT TREE\n    glPushMatrix();\n    loadObj("tree.obj", -4, 0.5, 3, 0.2 , colorTree);\n    glPopMatrix();\n\n    //IMPORT ROCK\n    GLfloat colorRock[] = { 0.0f, 0.0f, 0.0f, 1.0f };\n    glPushMatrix();\n    loadObj("rocks.obj", 25, 0, 4, 1 , colorRock);\n    glPopMatrix();\n\n\n    //Import katana\n    GLfloat colorKatana[] = { 0.75f, 0.75f, 0.75f, 1.0f };\n    glPushMatrix();\n    loadObj("katana.obj", 0, 1, 0, 0.04 , colorKatana);\n    glPopMatrix();\n\n    //Import window\n    GLfloat colorWindow[] = { 0.0f, 0.0f, 1.0f, 1.0f };\n    glPushMatrix();\n    loadObj("window.obj", 0, 3, -3, 1 , colorWindow);\n    glPopMatrix();\n\n\n//STAIRS\n\nglPushMatrix();\nGLfloat colorStairs[] = { 0.75f, 0.75f, 0.75f, 1.0f };\nDrawCube(5, 0, -1.4, 1, 3, .8, colorStairs);\nglPopMatrix();\n\n    glPushMatrix();\n\n    DrawCube(-5, 0, -1.4, 1, 3, .8, colorStairs);\n    glPopMatrix();\n\n\n    glLightfv(GL_LIGHT0, GL_POSITION, lpos);\n\n    glPushMatrix();\n    if(anim) {\n        tm = glutGet(GLUT_ELAPSED_TIME) - anim_start;\n        glRotatef(tm / 10.0f, 1, 0, 0);\n        glRotatef(tm / 10.0f, 0, 1, 0);\n    }\n\n    glPopMatrix();\n\n\n\n    //Left rectangle\n    glPushMatrix();\n//    float temp[4] = {0.0f, 0.0f, 0.0f, 0.0f};\n//    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,temp );\n    glColor3f(0.5, 0.5, 0.5);\n//    glTranslatef(-8, 3, -5);\n//    glScalef(3, 7, 4);\n//    glutSolidCube(1);\nGLfloat color[] = {0.58, 0.23, 0.19, 1.0};\n    DrawCube(-8, 3, -5, 3, 4, 7, color);\n    glPopMatrix();\n\n    glPushMatrix();\n//    float col[4] = {1.0f, 0.0f, 0.0f, 0.0f};\n//    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,col );\n\n//    glTranslatef(8, 3, -5);\n//    glScalef(3, 7, 4);\n//    glutSolidCube(1);\n    GLfloat color1[] = {1, 0.9, 0.5, 1.0};\n    DrawCube(8, 3, -5, 3, 4, 7,color);\n    glPopMatrix();\n\n\n    glPushMatrix();\n\n//    glTranslatef(6, 2.5, -5);\n//    glScalef(3, 5, 4);\n//    glutSolidCube(1);\n    GLfloat color2[] = {0.5, 0.5, 0.5, 1.0};\n    DrawCube(6, 2.5, -5, 3, 4, 5,color);\n    glPopMatrix();\n\n    glPushMatrix();\n\n//    glTranslatef(-6, 2.5, -5);\n//    glScalef(3, 5, 4);\n//    glutSolidCube(1);\n    GLfloat color3[] = {0.5, 0.5, 0.5, 1.0};\n    DrawCube(-6, 2.5, -5, 3, 4, 5,color);\n    glPopMatrix();\n\n    //Center\n    glPushMatrix();\n\n//    glTranslatef(0, 3, -5);\n//    glScalef(9, 7.5, 4);\n//    glutSolidCube(1);\n    GLfloat color4[] = {0.5, 0.5, 0.5, 1.0};\n    DrawCube(0, 3, -5, 9, 4, 7.5,color);\n    glPopMatrix();\n\n    //Dias\n    glPushMatrix();\n\n\n//    glTranslatef(0, 0.5, -2);\n//    glScalef(9, 1, 5);\n//    glutSolidCube(1);\n    GLfloat color5[] = {0.5, 0.5, 0.5, 1.0};\n    DrawCube(0, 0.5, -2, 9, 5, 1,color5);\n\n    glPopMatrix();\n\n    //SOLID SPHERE\n\n    glPushMatrix();\n    GLfloat colorGlass[] = {0.96, 0.99, 1, 0};\n    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, colorGlass);\n    glTranslated(0, 5, -5);\n    glScalef(1, 1, 0.5);\n    glutSolidSphere(3, 20, 20);\n    glPopMatrix();\n\n    //Grass paths\n    glPushMatrix();\n    GLfloat color6[] = {0.5, 0.5, 0.5, 1.0};\n    DrawCube(-2, 0, 5, 2, 10, 0.5, color6);\n    DrawCube(2, 0, 5, 2, 10, 0.5, color6);\n    glPopMatrix();\n\n\n    //BUSH\n\n\n\n\n\n\n    glBegin(GL_QUADS);\n    GLfloat color7[] = {0.5, 0.5, 0, 0};\n    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color7);\n    glVertex3f(-10, 0, -10);\n    glVertex3f(-10, 0, 10);\n    glVertex3f(10, 0, 10);\n    glVertex3f(10, 0, -10);\n    glEnd();\n\n\n\n    print_help();\n\n\n\n    //Display model\n\n    glutSwapBuffers();\n    nframes++;\n}\n\nvoid print_help(void)\n{\n    int i;\n    const char *s, **text;\n\n    glPushAttrib(GL_ENABLE_BIT);\n    glDisable(GL_LIGHTING);\n    glDisable(GL_DEPTH_TEST);\n\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    glMatrixMode(GL_PROJECTION);\n    glPushMatrix();\n    glLoadIdentity();\n    glOrtho(0, win_width, 0, win_height, -1, 1);\n\n    text = help ? helptext : helpprompt;\n\n    for(i=0; text[i]; i++) {\n        glColor3f(0, 0.1, 0);\n        glRasterPos2f(7, win_height - (i + 1) * 20 - 2);\n        s = text[i];\n        while(*s) {\n            glutBitmapCharacter(GLUT_BITMAP_9_BY_15, *s++);\n        }\n        glColor3f(0, 0.9, 0);\n        glRasterPos2f(5, win_height - (i + 1) * 20);\n        s = text[i];\n        while(*s) {\n            glutBitmapCharacter(GLUT_BITMAP_9_BY_15, *s++);\n        }\n    }\n\n    glPopMatrix();\n    glMatrixMode(GL_MODELVIEW);\n\n    glPopAttrib();\n}\n\n#define ZNEAR   0.5f\nvoid reshape(int x, int y)\n{\n    float vsz, aspect = (float)x / (float)y;\n    win_width = x;\n    win_height = y;\n\n    glViewport(0, 0, x, y);\n\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    vsz = 0.4663f * ZNEAR;\n    glFrustum(-aspect * vsz, aspect * vsz, -vsz, vsz, 0.5, 500.0);\n}\n\nvoid keypress(unsigned char key, int x, int y)\n{\n    static int fullscr;\n    static int prev_xsz, prev_ysz;\n\n    switch(key) {\n        case 27:\n        case \'q\':\n            exit(0);\n            break;\n\n        case \' \':\n            anim ^= 1;\n            glutIdleFunc(anim ? idle : 0);\n            glutPostRedisplay();\n\n            if(anim) {\n                anim_start = glutGet(GLUT_ELAPSED_TIME);\n                nframes = 0;\n            } else {\n                long tm = glutGet(GLUT_ELAPSED_TIME) - anim_start;\n                long fps = (nframes * 100000) / tm;\n                printf("framerate: %ld.%ld fps\\n", fps / 100, fps % 100);\n            }\n            break;\n\n        case \'\\n\':\n        case \'\\r\':\n            if(!(glutGetModifiers() & GLUT_ACTIVE_ALT)) {\n                break;\n            }\n        case \'f\':\n            fullscr ^= 1;\n            if(fullscr) {\n                prev_xsz = glutGet(GLUT_WINDOW_WIDTH);\n                prev_ysz = glutGet(GLUT_WINDOW_HEIGHT);\n                glutFullScreen();\n            } else {\n                glutReshapeWindow(prev_xsz, prev_ysz);\n            }\n            break;\n    }\n}\n\nvoid cameraYawRight(){\n    cam_yaw += 0.1;\n    if(cam_yaw > 360){\n        cam_yaw = 0;\n    }\n    glutPostRedisplay();\n}\n\nvoid cameraYawLeft(){\n    cam_yaw -= 0.1;\n    if(cam_yaw < 0){\n        cam_yaw = 360;\n    }\n    glutPostRedisplay();\n}\n\nvoid skeypress(int key, int x, int y)\n{\n    switch(key) {\n        case GLUT_KEY_F1:\n            help ^= 1;\n            glutPostRedisplay();\n            break;\n\n            case GLUT_KEY_F2:\n                cameraYawRight();\n            break;\n\n            case GLUT_KEY_F3:\n                cameraYawLeft();\n            break;\n\n\n        default:\n            break;\n    }\n}\n\nvoid mouse(int bn, int st, int x, int y)\n{\n    int bidx = bn - GLUT_LEFT_BUTTON;\n    bnstate[bidx] = st == GLUT_DOWN;\n    mouse_x = x;\n    mouse_y = y;\n}\n\nvoid motion(int x, int y)\n{\n    int dx = x - mouse_x;\n    int dy = y - mouse_y;\n    mouse_x = x;\n    mouse_y = y;\n\n    if(!(dx | dy)) return;\n\n    if(bnstate[0]) {\n        cam_theta += dx * 0.5;\n        cam_phi += dy * 0.5;\n        if(cam_phi < -90) cam_phi = -90;\n        if(cam_phi > 90) cam_phi = 90;\n        glutPostRedisplay();\n    }\n    if(bnstate[1]) {\n        float up[3], right[3];\n        float theta = cam_theta * M_PI / 180.0f;\n        float phi = cam_phi * M_PI / 180.0f;\n\n        up[0] = -sin(theta) * sin(phi);\n        up[1] = -cos(phi);\n        up[2] = cos(theta) * sin(phi);\n        right[0] = cos(theta);\n        right[1] = 0;\n        right[2] = sin(theta);\n\n        cam_pan[0] += (right[0] * dx + up[0] * dy) * 0.01;\n        cam_pan[1] += up[1] * dy * 0.01;\n        cam_pan[2] += (right[2] * dx + up[2] * dy) * 0.01;\n        glutPostRedisplay();\n    }\n    if(bnstate[2]) {\n        cam_dist += dy * 0.1;\n        if(cam_dist < 0) cam_dist = 0;\n        glutPostRedisplay();\n    }\n}\n\n\n\n\n')))}h.isMDXComponent=!0}}]);