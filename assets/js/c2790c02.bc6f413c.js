"use strict";(self.webpackChunkscenedocs=self.webpackChunkscenedocs||[]).push([[462],{3905:(e,t,n)=>{n.d(t,{Zo:()=>i,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function f(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var h=r.createContext({}),c=function(e){var t=r.useContext(h),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},i=function(e){var t=c(e.components);return r.createElement(h.Provider,{value:t},e.children)},s="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},P=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,h=e.parentName,i=f(e,["components","mdxType","originalType","parentName"]),s=c(n),P=a,d=s["".concat(h,".").concat(P)]||s[P]||g[P]||o;return n?r.createElement(d,l(l({ref:t},i),{},{components:n})):r.createElement(d,l({ref:t},i))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=P;var f={};for(var h in t)hasOwnProperty.call(t,h)&&(f[h]=t[h]);f.originalType=e,f[s]="string"==typeof e?e:a,l[1]=f;for(var c=2;c<o;c++)l[c]=n[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}P.displayName="MDXCreateElement"},1884:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>l,default:()=>s,frontMatter:()=>o,metadata:()=>f,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={sidebar_position:3,sidebar_label:"Algorithms in OpenGL"},l="Algorithm",f={unversionedId:"algo",id:"algo",title:"Algorithm",description:"Description",source:"@site/docs/algo.md",sourceDirName:".",slug:"/algo",permalink:"/a2docs/docs/algo",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,sidebar_label:"Algorithms in OpenGL"},sidebar:"tutorialSidebar",previous:{title:"OpenGL Instantiation",permalink:"/a2docs/docs/opengl"},next:{title:"Methodology",permalink:"/a2docs/docs/method"}},h={},c=[],i={toc:c};function s(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"algorithm"},"Algorithm"),(0,a.kt)("p",null,"Description\nThe cube was rendered by altering the normal's direction to point perpendicular to each face and corresponding vertices were specified by glVertex3f function.\nRoutine \u2018DrawCube\u2019 was used to render the cube."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"void DrawCube(GLfloat centerPosX, GLfloat centerPosY, GLfloat centerPosZ, GLfloat Clength, GLfloat Cbreadth, GLfloat Cheight, GLfloat colour[])\n{\nGLfloat halfLength = Clength * 0.5f;\nGLfloat halfbreadth = Cbreadth * 0.5f;\nGLfloat halfheight = Cheight * 0.5f;\nglEnable(GL_DEPTH_TEST);\nglEnable(GL_LIGHTING);\nglEnable(GL_LIGHT0);\nglShadeModel(GL_SMOOTH);\nglDisable(GL_CULL_FACE);\nGLfloat mat_ambient[] = { 0.7f, 0.7f, 0.7f, 1.0f };\nglMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);\nGLfloat mat_diffuse[] = { 0.1f, 0.5f, 0.8f, 1.0f };\nglMaterialfv(GL_FRONT, GL_DIFFUSE, colour);\nGLfloat mat_specular[] = { 1.0f, 1.0f, 1.0f, 1.0f };\nglMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);\nGLfloat mat_shininess[] = { 50.0f };\nglMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);\nGLfloat lightIntensity[] = { 0.7f, 0.7f, 0.7f, 1.0f };\nGLfloat light_position[] = { 2.0f, 6.0f, 3.0f, 0.0f };\nglLightfv(GL_LIGHT0, GL_POSITION, light_position);\nglLightfv(GL_LIGHT0, GL_DIFFUSE, lightIntensity);\nglBegin(GL_QUADS);\n\n      // Top face (y = 1.0f)\n      // Define vertices in counter-clockwise (CCW) order with normal pointing out\n \n      glNormal3f(0.0f, 1.0f, 0.0f);     // Normal points up\n      glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v1\n      glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v2\n      glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v3\n      glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v4\n \n      // Bottom face (y = -1.0f)\n \n      glNormal3f(0.0f, -1.0f, 0.0f);    // Normal points down\n      glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v5\n      glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v6\n      glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v7\n      glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v8\n \n      // Front face  (z = 1.0f)\n \n      glNormal3f(0.0f, 0.0f, 1.0f);     // Normal points towards viewer\n      glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v9\n      glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v10\n      glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v11\n      glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v12\n \n      // Back face (z = -1.0f)\n \n      glNormal3f(0.0f, 0.0f, -1.0f);    // Normal points away from viewer\n      glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v13\n      glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v14\n      glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v15\n      glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v16\n \n      // Left face (x = -1.0f)\n \n      glNormal3f(-1.0f, 0.0f, 0.0f);    // Normal points left\n      glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v17\n      glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v18\n      glVertex3f(centerPosX - halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v19\n      glVertex3f(centerPosX - halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v20\n \n      // Right face (x = 1.0f)\n \n      glNormal3f(1.0f, 0.0f, 0.0f);     // Normal points right\n      glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ + halfbreadth);  // v21\n      glVertex3f(centerPosX + halfLength, centerPosY - halfheight, centerPosZ - halfbreadth);  // v22\n      glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ - halfbreadth);  // v23\n      glVertex3f(centerPosX + halfLength, centerPosY + halfheight, centerPosZ + halfbreadth);  // v24\n      glEnd();\n}\n\n")))}s.isMDXComponent=!0}}]);